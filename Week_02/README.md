学习笔记
关于JDK1.6、1.7、1.8三个版本，HaspMap的实现是有区别的，特别是1.8，对hashmap的结构进行了较大的变化。

1.6整体采用的是位桶+链表的方式，而1.8使用的是位桶+链表+红黑树实现，链表的阈值是8，超过后就由链表变成红黑树，大大增加了查询的效率,HashMap结构图

构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比*Node.length），就会进行扩容，由于扩容存在数组复制，扩容是比较耗费时间的。

put/get 说明

1. 判断键值对数组tab[]是否为空或为null，否则resize()；

2. 根据键值key计算hash值得到插入的数组索引i，如果tab[i]==null，直接新建节点添加，否则转入3
3. 判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理。

4. 代码 (n - 1) & hash； hash先由key值通过hash(key)获取，再通过 hash &（n即为length-1）得到所在数组位置。一般对于哈希表的散列常用的方法有直接定址法，除留余数法等，既要便于计算，又能减少冲突，但是取模中的除法运算效率很低，所以HashMap则通过hash &（length-1）。
